<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fontai.deployment.plotters API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fontai.deployment.plotters</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import io
import base64
import typing as t

import tensorflow as tf
import numpy as np

import matplotlib
matplotlib.use(&#39;Agg&#39;)
import matplotlib.pyplot as plt

from abc import ABC, abstractmethod

from fontai.prediction.callbacks import SAAEFontSamplerCallback, TensorSAAEFontSamplerCallback

class AlphabetPlotter(ABC):

  @classmethod
  @abstractmethod
  def generate_font(cls):
    pass

  @classmethod
  @abstractmethod
  def plot_font(cls):
    pass

  def fig_to_str(cls, in_fig, close_all=True, **save_args):
    &#34;&#34;&#34;Maps a pyplot figure to base64 encoding for display inside a Dash app
    
    Args:
        in_fig : Matplotlib figure
        close_all (bool, optional): Close all figures after saving to an internal buffer
        **save_args: Arguments passed when saving figure to an internal buffer
    
    Returns:
        str: base64-encoded image
    &#34;&#34;&#34;
    out_img = io.BytesIO()
    in_fig.savefig(out_img, format=&#39;png&#39;, **save_args)
    if close_all:
        in_fig.clf()
        plt.close(&#39;all&#39;)
    out_img.seek(0)  # rewind file
    encoded = base64.b64encode(out_img.read()).decode(&#34;ascii&#34;).replace(&#34;\n&#34;, &#34;&#34;)
    return f&#34;data:image/png;base64,{encoded}&#34;



class SAAEAlphabetPlotter(AlphabetPlotter):

  @classmethod
  def generate_font(cls, model:tf.keras.Model, style_vector: np.array, charset_size: int):
    &#34;&#34;&#34;Creates a set of character images as numpy arrays from a given font style vector and charset size. Assumes images are along the first axis in the resulting tensor, i.e. images are output examples.
    
    Args:
        model (tf.keras.Model): Generative model. Its input must be a vector of size charset_size + style_dim, and it should output an image as a 3-dimensional tensor
        style_vector (np.array): style vector
        charset_size (int): number of characters in font
    
    Returns:
        np.array: four-dimensional array where the first dimension correspond to image indices and the last to image channels
    &#34;&#34;&#34;
    # sample one hot encoded labels
    labels = []
    for k in range(charset_size):
      onehot = np.zeros((1,charset_size), dtype=np.float32)
      onehot[0,k] = 1.0
      labels.append(np.concatenate([style_vector,onehot],axis=-1))
    
    fully_encoded = np.array(labels, dtype=np.float32)

    chars = model.predict(fully_encoded)
    return chars



  @classmethod
  def plot_font(cls, imgs: t.Union[tf.Tensor, np.ndarray], n_cols = 7) -&gt; None:
    &#34;&#34;&#34;Utility function to plot a sequence of images from numpy array in a matrix plot
    
    Args:
        imgs (t.Union[tf.Tensor, np.ndarray]): 4-dimensional array of images
        output_file (str): output file
        n_cols (int, optional): number of columns in output figure
    &#34;&#34;&#34;
    # plot multiple images
    n_imgs, height, width, c = imgs.shape
    n_rows = int(np.ceil(n_imgs/n_cols))

    fig, axs = plt.subplots(n_rows, n_cols)
    for i in range(n_imgs):
      x = imgs[i]
      if isinstance(x, np.ndarray):
        x_ = x
      else:
        x_ = x.numpy()
      np_x = (255 * x_).astype(np.uint8).reshape((height,width))
      axs[int(i/n_cols), i%n_cols].imshow(np_x, cmap=&#34;Greys&#34;)

    for k in range(n_rows*n_cols):
      axs[int(k/n_cols), k%n_cols].axis(&#34;off&#34;)
    
    return fig



class TensorSAAEAlphabetPlotter(AlphabetPlotter):

  @classmethod
  def generate_font(cls, model:tf.keras.Model, style_vector: np.array, *args, **kwargs):
    &#34;&#34;&#34;Creates a set of character images as numpy arrays from a given font style vector and charset size. Assumes imags are along the last channels, i.e. images are channels in the resulting tensor. It does not pass character labels to the model as they are not needed (since they are encoded in the channel index).
    
    Args:
        model (tf.keras.Model): Generative model. Its input must be a vector of size charset_size + style_dim, and it should output an image as a 3-dimensional tensor
        style_vector (np.array): style vector
        charset_size (int): number of characters in font
    
    Returns:
        np.array: four-dimensional array where the first dimension correspond to image indices and the last to image channels
    &#34;&#34;&#34;
    # sample one hot encoded labels
    

    chars = model.predict(style_vector.reshape((1,-1)))
    return chars

  @classmethod
  def plot_font(cls, imgs: t.Union[tf.Tensor, np.ndarray], n_cols = 7) -&gt; None:
    &#34;&#34;&#34;Utility function to plot a sequence of images from numpy array in a matrix plot
    
    Args:
        imgs (t.Union[tf.Tensor, np.ndarray]): 4-dimensional array of images
        output_file (str): output file
        n_cols (int, optional): number of columns in output figure
    &#34;&#34;&#34;
    # plot multiple images
    n_fonts, height, width, n_imgs = imgs.shape
    n_rows = int(np.ceil(n_imgs/n_cols))

    fig, axs = plt.subplots(n_rows, n_cols)
    for i in range(n_imgs):
      x = imgs[0,:,:,i]
      if isinstance(x, np.ndarray):
        x_ = x
      else:
        x_ = x.numpy()
      np_x = (255 * x_).astype(np.uint8).reshape((height,width))
      axs[int(i/n_cols), i%n_cols].imshow(np_x, cmap=&#34;Greys&#34;)

    for k in range(n_rows*n_cols):
      axs[int(k/n_cols), k%n_cols].axis(&#34;off&#34;)
    
    return fig</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fontai.deployment.plotters.AlphabetPlotter"><code class="flex name class">
<span>class <span class="ident">AlphabetPlotter</span></span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AlphabetPlotter(ABC):

  @classmethod
  @abstractmethod
  def generate_font(cls):
    pass

  @classmethod
  @abstractmethod
  def plot_font(cls):
    pass

  def fig_to_str(cls, in_fig, close_all=True, **save_args):
    &#34;&#34;&#34;Maps a pyplot figure to base64 encoding for display inside a Dash app
    
    Args:
        in_fig : Matplotlib figure
        close_all (bool, optional): Close all figures after saving to an internal buffer
        **save_args: Arguments passed when saving figure to an internal buffer
    
    Returns:
        str: base64-encoded image
    &#34;&#34;&#34;
    out_img = io.BytesIO()
    in_fig.savefig(out_img, format=&#39;png&#39;, **save_args)
    if close_all:
        in_fig.clf()
        plt.close(&#39;all&#39;)
    out_img.seek(0)  # rewind file
    encoded = base64.b64encode(out_img.read()).decode(&#34;ascii&#34;).replace(&#34;\n&#34;, &#34;&#34;)
    return f&#34;data:image/png;base64,{encoded}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fontai.deployment.plotters.SAAEAlphabetPlotter" href="#fontai.deployment.plotters.SAAEAlphabetPlotter">SAAEAlphabetPlotter</a></li>
<li><a title="fontai.deployment.plotters.TensorSAAEAlphabetPlotter" href="#fontai.deployment.plotters.TensorSAAEAlphabetPlotter">TensorSAAEAlphabetPlotter</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fontai.deployment.plotters.AlphabetPlotter.generate_font"><code class="name flex">
<span>def <span class="ident">generate_font</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
@abstractmethod
def generate_font(cls):
  pass</code></pre>
</details>
</dd>
<dt id="fontai.deployment.plotters.AlphabetPlotter.plot_font"><code class="name flex">
<span>def <span class="ident">plot_font</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
@abstractmethod
def plot_font(cls):
  pass</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fontai.deployment.plotters.AlphabetPlotter.fig_to_str"><code class="name flex">
<span>def <span class="ident">fig_to_str</span></span>(<span>cls, in_fig, close_all=True, **save_args)</span>
</code></dt>
<dd>
<div class="desc"><p>Maps a pyplot figure to base64 encoding for display inside a Dash app</p>
<h2 id="args">Args</h2>
<dl>
<dt>in_fig : Matplotlib figure</dt>
<dt><strong><code>close_all</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Close all figures after saving to an internal buffer</dd>
<dt><strong><code>**save_args</code></strong></dt>
<dd>Arguments passed when saving figure to an internal buffer</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>base64-encoded image</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fig_to_str(cls, in_fig, close_all=True, **save_args):
  &#34;&#34;&#34;Maps a pyplot figure to base64 encoding for display inside a Dash app
  
  Args:
      in_fig : Matplotlib figure
      close_all (bool, optional): Close all figures after saving to an internal buffer
      **save_args: Arguments passed when saving figure to an internal buffer
  
  Returns:
      str: base64-encoded image
  &#34;&#34;&#34;
  out_img = io.BytesIO()
  in_fig.savefig(out_img, format=&#39;png&#39;, **save_args)
  if close_all:
      in_fig.clf()
      plt.close(&#39;all&#39;)
  out_img.seek(0)  # rewind file
  encoded = base64.b64encode(out_img.read()).decode(&#34;ascii&#34;).replace(&#34;\n&#34;, &#34;&#34;)
  return f&#34;data:image/png;base64,{encoded}&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fontai.deployment.plotters.SAAEAlphabetPlotter"><code class="flex name class">
<span>class <span class="ident">SAAEAlphabetPlotter</span></span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SAAEAlphabetPlotter(AlphabetPlotter):

  @classmethod
  def generate_font(cls, model:tf.keras.Model, style_vector: np.array, charset_size: int):
    &#34;&#34;&#34;Creates a set of character images as numpy arrays from a given font style vector and charset size. Assumes images are along the first axis in the resulting tensor, i.e. images are output examples.
    
    Args:
        model (tf.keras.Model): Generative model. Its input must be a vector of size charset_size + style_dim, and it should output an image as a 3-dimensional tensor
        style_vector (np.array): style vector
        charset_size (int): number of characters in font
    
    Returns:
        np.array: four-dimensional array where the first dimension correspond to image indices and the last to image channels
    &#34;&#34;&#34;
    # sample one hot encoded labels
    labels = []
    for k in range(charset_size):
      onehot = np.zeros((1,charset_size), dtype=np.float32)
      onehot[0,k] = 1.0
      labels.append(np.concatenate([style_vector,onehot],axis=-1))
    
    fully_encoded = np.array(labels, dtype=np.float32)

    chars = model.predict(fully_encoded)
    return chars



  @classmethod
  def plot_font(cls, imgs: t.Union[tf.Tensor, np.ndarray], n_cols = 7) -&gt; None:
    &#34;&#34;&#34;Utility function to plot a sequence of images from numpy array in a matrix plot
    
    Args:
        imgs (t.Union[tf.Tensor, np.ndarray]): 4-dimensional array of images
        output_file (str): output file
        n_cols (int, optional): number of columns in output figure
    &#34;&#34;&#34;
    # plot multiple images
    n_imgs, height, width, c = imgs.shape
    n_rows = int(np.ceil(n_imgs/n_cols))

    fig, axs = plt.subplots(n_rows, n_cols)
    for i in range(n_imgs):
      x = imgs[i]
      if isinstance(x, np.ndarray):
        x_ = x
      else:
        x_ = x.numpy()
      np_x = (255 * x_).astype(np.uint8).reshape((height,width))
      axs[int(i/n_cols), i%n_cols].imshow(np_x, cmap=&#34;Greys&#34;)

    for k in range(n_rows*n_cols):
      axs[int(k/n_cols), k%n_cols].axis(&#34;off&#34;)
    
    return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fontai.deployment.plotters.AlphabetPlotter" href="#fontai.deployment.plotters.AlphabetPlotter">AlphabetPlotter</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fontai.deployment.plotters.SAAEAlphabetPlotter.generate_font"><code class="name flex">
<span>def <span class="ident">generate_font</span></span>(<span>model: tensorflow.python.keras.engine.training.Model, style_vector: <built-in function array>, charset_size: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a set of character images as numpy arrays from a given font style vector and charset size. Assumes images are along the first axis in the resulting tensor, i.e. images are output examples.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>tf.keras.Model</code></dt>
<dd>Generative model. Its input must be a vector of size charset_size + style_dim, and it should output an image as a 3-dimensional tensor</dd>
<dt><strong><code>style_vector</code></strong> :&ensp;<code>np.array</code></dt>
<dd>style vector</dd>
<dt><strong><code>charset_size</code></strong> :&ensp;<code>int</code></dt>
<dd>number of characters in font</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.array</code></dt>
<dd>four-dimensional array where the first dimension correspond to image indices and the last to image channels</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def generate_font(cls, model:tf.keras.Model, style_vector: np.array, charset_size: int):
  &#34;&#34;&#34;Creates a set of character images as numpy arrays from a given font style vector and charset size. Assumes images are along the first axis in the resulting tensor, i.e. images are output examples.
  
  Args:
      model (tf.keras.Model): Generative model. Its input must be a vector of size charset_size + style_dim, and it should output an image as a 3-dimensional tensor
      style_vector (np.array): style vector
      charset_size (int): number of characters in font
  
  Returns:
      np.array: four-dimensional array where the first dimension correspond to image indices and the last to image channels
  &#34;&#34;&#34;
  # sample one hot encoded labels
  labels = []
  for k in range(charset_size):
    onehot = np.zeros((1,charset_size), dtype=np.float32)
    onehot[0,k] = 1.0
    labels.append(np.concatenate([style_vector,onehot],axis=-1))
  
  fully_encoded = np.array(labels, dtype=np.float32)

  chars = model.predict(fully_encoded)
  return chars</code></pre>
</details>
</dd>
<dt id="fontai.deployment.plotters.SAAEAlphabetPlotter.plot_font"><code class="name flex">
<span>def <span class="ident">plot_font</span></span>(<span>imgs: Union[tensorflow.python.framework.ops.Tensor, numpy.ndarray], n_cols=7) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Utility function to plot a sequence of images from numpy array in a matrix plot</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>imgs</code></strong> :&ensp;<code>t.Union[tf.Tensor, np.ndarray]</code></dt>
<dd>4-dimensional array of images</dd>
<dt><strong><code>output_file</code></strong> :&ensp;<code>str</code></dt>
<dd>output file</dd>
<dt><strong><code>n_cols</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>number of columns in output figure</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def plot_font(cls, imgs: t.Union[tf.Tensor, np.ndarray], n_cols = 7) -&gt; None:
  &#34;&#34;&#34;Utility function to plot a sequence of images from numpy array in a matrix plot
  
  Args:
      imgs (t.Union[tf.Tensor, np.ndarray]): 4-dimensional array of images
      output_file (str): output file
      n_cols (int, optional): number of columns in output figure
  &#34;&#34;&#34;
  # plot multiple images
  n_imgs, height, width, c = imgs.shape
  n_rows = int(np.ceil(n_imgs/n_cols))

  fig, axs = plt.subplots(n_rows, n_cols)
  for i in range(n_imgs):
    x = imgs[i]
    if isinstance(x, np.ndarray):
      x_ = x
    else:
      x_ = x.numpy()
    np_x = (255 * x_).astype(np.uint8).reshape((height,width))
    axs[int(i/n_cols), i%n_cols].imshow(np_x, cmap=&#34;Greys&#34;)

  for k in range(n_rows*n_cols):
    axs[int(k/n_cols), k%n_cols].axis(&#34;off&#34;)
  
  return fig</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fontai.deployment.plotters.AlphabetPlotter" href="#fontai.deployment.plotters.AlphabetPlotter">AlphabetPlotter</a></b></code>:
<ul class="hlist">
<li><code><a title="fontai.deployment.plotters.AlphabetPlotter.fig_to_str" href="#fontai.deployment.plotters.AlphabetPlotter.fig_to_str">fig_to_str</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fontai.deployment.plotters.TensorSAAEAlphabetPlotter"><code class="flex name class">
<span>class <span class="ident">TensorSAAEAlphabetPlotter</span></span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TensorSAAEAlphabetPlotter(AlphabetPlotter):

  @classmethod
  def generate_font(cls, model:tf.keras.Model, style_vector: np.array, *args, **kwargs):
    &#34;&#34;&#34;Creates a set of character images as numpy arrays from a given font style vector and charset size. Assumes imags are along the last channels, i.e. images are channels in the resulting tensor. It does not pass character labels to the model as they are not needed (since they are encoded in the channel index).
    
    Args:
        model (tf.keras.Model): Generative model. Its input must be a vector of size charset_size + style_dim, and it should output an image as a 3-dimensional tensor
        style_vector (np.array): style vector
        charset_size (int): number of characters in font
    
    Returns:
        np.array: four-dimensional array where the first dimension correspond to image indices and the last to image channels
    &#34;&#34;&#34;
    # sample one hot encoded labels
    

    chars = model.predict(style_vector.reshape((1,-1)))
    return chars

  @classmethod
  def plot_font(cls, imgs: t.Union[tf.Tensor, np.ndarray], n_cols = 7) -&gt; None:
    &#34;&#34;&#34;Utility function to plot a sequence of images from numpy array in a matrix plot
    
    Args:
        imgs (t.Union[tf.Tensor, np.ndarray]): 4-dimensional array of images
        output_file (str): output file
        n_cols (int, optional): number of columns in output figure
    &#34;&#34;&#34;
    # plot multiple images
    n_fonts, height, width, n_imgs = imgs.shape
    n_rows = int(np.ceil(n_imgs/n_cols))

    fig, axs = plt.subplots(n_rows, n_cols)
    for i in range(n_imgs):
      x = imgs[0,:,:,i]
      if isinstance(x, np.ndarray):
        x_ = x
      else:
        x_ = x.numpy()
      np_x = (255 * x_).astype(np.uint8).reshape((height,width))
      axs[int(i/n_cols), i%n_cols].imshow(np_x, cmap=&#34;Greys&#34;)

    for k in range(n_rows*n_cols):
      axs[int(k/n_cols), k%n_cols].axis(&#34;off&#34;)
    
    return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fontai.deployment.plotters.AlphabetPlotter" href="#fontai.deployment.plotters.AlphabetPlotter">AlphabetPlotter</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fontai.deployment.plotters.TensorSAAEAlphabetPlotter.generate_font"><code class="name flex">
<span>def <span class="ident">generate_font</span></span>(<span>model: tensorflow.python.keras.engine.training.Model, style_vector: <built-in function array>, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a set of character images as numpy arrays from a given font style vector and charset size. Assumes imags are along the last channels, i.e. images are channels in the resulting tensor. It does not pass character labels to the model as they are not needed (since they are encoded in the channel index).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>tf.keras.Model</code></dt>
<dd>Generative model. Its input must be a vector of size charset_size + style_dim, and it should output an image as a 3-dimensional tensor</dd>
<dt><strong><code>style_vector</code></strong> :&ensp;<code>np.array</code></dt>
<dd>style vector</dd>
<dt><strong><code>charset_size</code></strong> :&ensp;<code>int</code></dt>
<dd>number of characters in font</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.array</code></dt>
<dd>four-dimensional array where the first dimension correspond to image indices and the last to image channels</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def generate_font(cls, model:tf.keras.Model, style_vector: np.array, *args, **kwargs):
  &#34;&#34;&#34;Creates a set of character images as numpy arrays from a given font style vector and charset size. Assumes imags are along the last channels, i.e. images are channels in the resulting tensor. It does not pass character labels to the model as they are not needed (since they are encoded in the channel index).
  
  Args:
      model (tf.keras.Model): Generative model. Its input must be a vector of size charset_size + style_dim, and it should output an image as a 3-dimensional tensor
      style_vector (np.array): style vector
      charset_size (int): number of characters in font
  
  Returns:
      np.array: four-dimensional array where the first dimension correspond to image indices and the last to image channels
  &#34;&#34;&#34;
  # sample one hot encoded labels
  

  chars = model.predict(style_vector.reshape((1,-1)))
  return chars</code></pre>
</details>
</dd>
<dt id="fontai.deployment.plotters.TensorSAAEAlphabetPlotter.plot_font"><code class="name flex">
<span>def <span class="ident">plot_font</span></span>(<span>imgs: Union[tensorflow.python.framework.ops.Tensor, numpy.ndarray], n_cols=7) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Utility function to plot a sequence of images from numpy array in a matrix plot</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>imgs</code></strong> :&ensp;<code>t.Union[tf.Tensor, np.ndarray]</code></dt>
<dd>4-dimensional array of images</dd>
<dt><strong><code>output_file</code></strong> :&ensp;<code>str</code></dt>
<dd>output file</dd>
<dt><strong><code>n_cols</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>number of columns in output figure</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def plot_font(cls, imgs: t.Union[tf.Tensor, np.ndarray], n_cols = 7) -&gt; None:
  &#34;&#34;&#34;Utility function to plot a sequence of images from numpy array in a matrix plot
  
  Args:
      imgs (t.Union[tf.Tensor, np.ndarray]): 4-dimensional array of images
      output_file (str): output file
      n_cols (int, optional): number of columns in output figure
  &#34;&#34;&#34;
  # plot multiple images
  n_fonts, height, width, n_imgs = imgs.shape
  n_rows = int(np.ceil(n_imgs/n_cols))

  fig, axs = plt.subplots(n_rows, n_cols)
  for i in range(n_imgs):
    x = imgs[0,:,:,i]
    if isinstance(x, np.ndarray):
      x_ = x
    else:
      x_ = x.numpy()
    np_x = (255 * x_).astype(np.uint8).reshape((height,width))
    axs[int(i/n_cols), i%n_cols].imshow(np_x, cmap=&#34;Greys&#34;)

  for k in range(n_rows*n_cols):
    axs[int(k/n_cols), k%n_cols].axis(&#34;off&#34;)
  
  return fig</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fontai.deployment.plotters.AlphabetPlotter" href="#fontai.deployment.plotters.AlphabetPlotter">AlphabetPlotter</a></b></code>:
<ul class="hlist">
<li><code><a title="fontai.deployment.plotters.AlphabetPlotter.fig_to_str" href="#fontai.deployment.plotters.AlphabetPlotter.fig_to_str">fig_to_str</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fontai.deployment" href="index.html">fontai.deployment</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fontai.deployment.plotters.AlphabetPlotter" href="#fontai.deployment.plotters.AlphabetPlotter">AlphabetPlotter</a></code></h4>
<ul class="">
<li><code><a title="fontai.deployment.plotters.AlphabetPlotter.fig_to_str" href="#fontai.deployment.plotters.AlphabetPlotter.fig_to_str">fig_to_str</a></code></li>
<li><code><a title="fontai.deployment.plotters.AlphabetPlotter.generate_font" href="#fontai.deployment.plotters.AlphabetPlotter.generate_font">generate_font</a></code></li>
<li><code><a title="fontai.deployment.plotters.AlphabetPlotter.plot_font" href="#fontai.deployment.plotters.AlphabetPlotter.plot_font">plot_font</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fontai.deployment.plotters.SAAEAlphabetPlotter" href="#fontai.deployment.plotters.SAAEAlphabetPlotter">SAAEAlphabetPlotter</a></code></h4>
<ul class="">
<li><code><a title="fontai.deployment.plotters.SAAEAlphabetPlotter.generate_font" href="#fontai.deployment.plotters.SAAEAlphabetPlotter.generate_font">generate_font</a></code></li>
<li><code><a title="fontai.deployment.plotters.SAAEAlphabetPlotter.plot_font" href="#fontai.deployment.plotters.SAAEAlphabetPlotter.plot_font">plot_font</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fontai.deployment.plotters.TensorSAAEAlphabetPlotter" href="#fontai.deployment.plotters.TensorSAAEAlphabetPlotter">TensorSAAEAlphabetPlotter</a></code></h4>
<ul class="">
<li><code><a title="fontai.deployment.plotters.TensorSAAEAlphabetPlotter.generate_font" href="#fontai.deployment.plotters.TensorSAAEAlphabetPlotter.generate_font">generate_font</a></code></li>
<li><code><a title="fontai.deployment.plotters.TensorSAAEAlphabetPlotter.plot_font" href="#fontai.deployment.plotters.TensorSAAEAlphabetPlotter.plot_font">plot_font</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>